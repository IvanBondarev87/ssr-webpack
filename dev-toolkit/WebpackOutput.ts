import path from 'path';
import webpack, { HotModuleReplacementPlugin } from 'webpack';
import { createFsFromVolume, Volume, IFs } from 'memfs';
import nodeExternals from 'webpack-node-externals';
import requireFromString, { RawSourceMap } from './require-from-string';
import listFiles from './list-files';
import hotUpdater from './emitter';
import { name as packageName } from '../package.json';

const hotUpdateEntry = './dev-toolkit/hot-update.ts';
/**
 * Returns a derived entry value by adding the hot-update module to the given entry value
 */ 
function getDerivedEntry(entry: webpack.Configuration['entry']) {
  if (entry instanceof Array) return [hotUpdateEntry, ...entry];
  if (entry instanceof Object) {
    const derivedEntry = {};
    const chunkList = Object.keys(entry);
    for (const chunkId of chunkList) {
      derivedEntry[chunkId] = getDerivedEntry(entry[chunkId]);
    }
    return derivedEntry;
  };
  if (typeof entry === 'string') return [hotUpdateEntry, entry];
  throw new Error('Cannot merge entries.');
}

class WebpackOutput {

  [index: string]: any;
  
  private compiler: webpack.Compiler;
  private files: string[] = null;

  constructor(config: webpack.Configuration) {

    const derivedConfig: webpack.Configuration = {
      ...config,
      entry: getDerivedEntry(config.entry),
      plugins: [
        ...config.plugins,
        new HotModuleReplacementPlugin(),
      ],
      externals: [
        nodeExternals(),
        // Excludes the emitter module from a bundle
        // to be able to fire events form outside a bundle
        ({ context, request }, callback) => {
          if (context === __dirname && request === './emitter')
            callback(null, request);
          else callback();
        },
      ],
    };

    this.compiler = webpack(derivedConfig);
    this.compiler.outputFileSystem = createFsFromVolume(new Volume());
    this.compiler.watch({}, this.handleEmit.bind(this));
  }

  /**
   * Reads the content of the file with the specified name
   */
  private readFile(filename: string) {
    const outputFileSystem = this.compiler.outputFileSystem as IFs;

    // Gets the absolute path to the specified file
    const outputPath = this.compiler.outputPath;
    const pathToFile = path.join(outputPath, filename);

    // Returns undefined if the file does not exists
    if (!outputFileSystem.existsSync(pathToFile)) return undefined;

    const buffer = outputFileSystem.readFileSync(pathToFile) as Buffer;
    return buffer.toString();
  }

  /**
   * Reads and loads file with the specified name
   */
  private loadModule(filename: string, id: string) {
    
    const code = this.readFile(filename);

    // Reads and loads sourcemap file if the current is a javascript file
    let sourceMap: RawSourceMap = null;
    if (path.extname(filename) === '.js') {
      const mapFile = this.readFile(filename + '.map');
      if (mapFile !== undefined) {
        sourceMap = JSON.parse(mapFile) as RawSourceMap;
        // Overrides sources defined by webpack for correct mapping
        sourceMap.sources = sourceMap.sources.map(s => s.replace(`webpack://${packageName}/`, ''));
      }
    }

    return requireFromString(code, id, sourceMap);
  }

  /**
   * Loads and appends the chunk with the specified id to the current instance
   */
  private loadChunk(chunkId: string, stats: webpack.StatsCompilation) {
    // Gets the name of the chunk file because it may differ from its id
    const filename = stats.assetsByChunkName[chunkId][0];
    this[chunkId] = this.loadModule(filename, chunkId);
  };

  private handleEmit(error: Error, result: webpack.Stats) {

    if (error) return;

    const stats = result.toJson({ errors: true, groupAssetsByChunk: true, modules: true });
    if (stats.errorsCount > 0) return;

    // Loads generated chunks on first call
    if (this.files === null) {

      const chunks = Object.keys(stats.assetsByChunkName);
      this.files = listFiles(this.compiler);
      for (const chunkId of chunks) this.loadChunk(chunkId, stats);

    // Otherwise updates using HMR
    } else {

      // Gets a list of newly emitted files by excluding items in the last list from the current list
      const currFiles = listFiles(this.compiler);
      const newFiles = currFiles.filter(f => !this.files.includes(f));
      this.files = currFiles;

      // Filters including files generated by HMR and loads each of the resulting list
      newFiles.filter(f => 
        f.endsWith('.hot-update.js')
        || f.endsWith('.hot-update.json')
      ).forEach(filename => this.loadModule(filename, './' + filename))

      // Gets a list of entry module ids for each chunk
      const moduleIdsByChunkName = stats.modules
      .filter(m => m.depth === 0)
      .filter(m => m.id !== './dev-toolkit/hot-update.ts')
      .reduce(
        (res, m) => ({
          ...res,
          [m.chunks[0]]: m.id
        }),
        {}
      );
      
      // Triggers an update event on the current instance, providing a handler for reloading chunks
      hotUpdater.emit(
        'update chunks',
        this,
        moduleIdsByChunkName,
        (chunkId: string) => this.loadChunk(chunkId, stats)
      );

    }
  }

}

export default WebpackOutput;
